# -*- coding: utf-8 -*-
"""B·∫£n sao c·ªßa MAI Project - Tran Hung.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QLjGPxUCCG8oVS_P8ib_s9E17RHtmLac

# 1. Download Data
"""

! pip install -q kaggle

from google.colab import files

files.upload()

!rm -r ~/.kaggle
!mkdir ~/.kaggle
!mv ./kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets list

!kaggle datasets download -d fedesoriano/stroke-prediction-dataset

!unzip '/content/stroke-prediction-dataset.zip' -d data

import pandas as pd
import pandas as pd
import numpy as np
import copy
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("/content/data/healthcare-dataset-stroke-data.csv")
display(df)

"""#2. EDA

##Data's summary
"""

df.describe()

df2 = df.copy()

plt.rcParams["figure.figsize"] = [7.00, 3.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.countplot(x = df2['stroke'])
plt.title('Distribution by Stroke.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.01))
plt.show()

"""##Relationship between Hypertension and Stroke"""

plt.rcParams["figure.figsize"] = [7.00, 3.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.countplot(x = df2['hypertension'], hue = df['stroke'])
plt.title('Distribution by Hypertension.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.01))
plt.show()

#The likelihood of stroke in person have hypertension is higher.
#13% vs 4%

"""##Relationship between Gender and Stroke"""

plt.rcParams["figure.figsize"] = [7.00, 3.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.countplot(x = df2['gender'], hue = df['stroke'])
plt.title('Distribution by Gender.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.01))
plt.show()
#The proportion of people who had a stroke in the hypertension category is much higher than the proportion of people who had a stroke in the No hypertension category
#But the number of people who had hypertension is significantly lower than the number of people who didn't, so it cannot be confidently concluded that people with hypertension is more likely to suffer from a stroke than people with no hypertension

plt.rcParams["figure.figsize"] = [7.00, 3.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.countplot(x = df2['heart_disease'], hue = df2['stroke'])
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.01))
plt.title('Distribution by heart disease.')
plt.show()

plt.rcParams["figure.figsize"] = [7.00, 3.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.countplot(x = df2['smoking_status'], hue = df['stroke'])
plt.title('Distribution by Smoking Status.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.01))
plt.show()

plt.rcParams["figure.figsize"] = [7.00, 3.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.countplot(x = df2['ever_married'], hue = df['stroke'])
plt.title('Distribution by Married Status.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.01))
plt.show()

plt.rcParams["figure.figsize"] = [12.00, 7.50]
plt.rcParams["figure.autolayout"] = True
#plt.figure(figsize = (12, 7))
ax = sns.histplot(df2, x="age", kde=True, hue = 'stroke')
plt.title('Distribution by Age group.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.01))
plt.show()
# Most people having a stroke are old people 'cause as age increases, there are more favorable factors for the disease to appear

plt.rcParams["figure.figsize"] = [12.00, 7.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.histplot(df2, x="smoking_status", hue = 'stroke')
plt.title('Distribution by Smoking status group.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.4, p.get_height()+0.05))
plt.show()
#formerly: 7.9%, never: 4.7%, smoke: 5.3%

plt.rcParams["figure.figsize"] = [12.00, 7.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.histplot(df2, x='gender',hue = 'stroke')
plt.title("Correlation between gender and the likelihood of having a stroke")
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.4, p.get_height()+0.05))
plt.show()
#Female: 4.7% stroke, Male: 5.1% stroke

plt.figure(figsize = (36, 20))
sns.histplot(df, x="bmi", kde=True, hue = 'stroke')
plt.title('Distribution by body mass index group.')
plt.show()

print('People have BMI < mean of BMI: ')
print(df[(df.bmi < df.bmi.mean()) & (df.stroke == 1)].bmi.count()/ df[(df.bmi < df.bmi.mean())].bmi.count()*100)
print('People have BMI >= mean of BMI: ')
print(df[(df.bmi >= df.bmi.mean()) & (df.stroke == 1)].bmi.count()/ df[(df.bmi >= df.bmi.mean())].bmi.count()*100)

plt.rcParams["figure.figsize"] = [12.00, 7.50]
plt.rcParams["figure.autolayout"] = True
plt.figure(figsize = (12, 8))
ax = sns.countplot(x = df2['Residence_type'], hue = df['stroke'])
plt.title('Distribution by Residence type.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.05))
plt.show()

plt.rcParams["figure.figsize"] = [24.00, 20.0]
plt.rcParams["figure.autolayout"] = True
ax = sns.histplot(df2, x="avg_glucose_level",kde='True', hue = 'stroke')
plt.title('Distribution by average glucose level in blood status group.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.05))
plt.show()

print('People have low avg_glucose_level: ')
print(df[(df.avg_glucose_level < df.avg_glucose_level.mean()) & (df.stroke == 1)].avg_glucose_level.count()/ df[(df.avg_glucose_level < df.avg_glucose_level.mean())].avg_glucose_level.count()*100)
print('People have high avg_glucose_level: ')
print(df[(df.avg_glucose_level >= df.avg_glucose_level.mean()) & (df.stroke == 1)].avg_glucose_level.count()/ df[(df.avg_glucose_level >= df.avg_glucose_level.mean())].avg_glucose_level.count()*100)
#Most people having a stroke usually have a higher Average glucose level than those who never had a stroke because high glucose level sugar can cause atherosclerosis

plt.rcParams["figure.figsize"] = [12.00, 7.50]
plt.rcParams["figure.autolayout"] = True
ax = sns.countplot(x = df2['work_type'], hue = df['stroke'])
plt.title('Distribution by Work type.')
for p in ax.patches:
   ax.annotate('{:.1f}'.format(p.get_height()), (p.get_x()+0.1, p.get_height()+0.05))
plt.show()
#Private: 5%, self-employed:8%, govt_job: 5%

"""# 3. Data *Processing*

## Clean unknown data
"""

df.isnull().sum()

maxfreq = df["bmi"].mode().iloc[0]

df["bmi"] = df["bmi"].fillna(maxfreq)
display(df)

"""##Encoding

###ever_married feature
"""

df['ever_married'] = np.where((df.ever_married == 'Yes'),1,0)
df

"""###Residence_type feature"""

df['Residence_type'].value_counts()

df['Residence_type'] = np.where((df.Residence_type == 'Urban'),1,0)
df

"""###smoking_status feature"""

df['smoking_status'].value_counts()

df.loc[(df.smoking_status == 'Unknown'),'smoking_status']=-1
df.loc[(df.smoking_status == 'never smoked'),'smoking_status']=0
df.loc[(df.smoking_status == 'formerly smoked'),'smoking_status']=1
df.loc[(df.smoking_status == 'smokes'),'smoking_status']=2
df

"""###work_type feature"""

df = pd.get_dummies(df, columns = ['work_type'], drop_first=True)

df

"""###gender feature"""

df['gender'].value_counts()

df.loc[(df.gender == 'Male'),'gender'] = 0
df.loc[(df.gender == 'Female'),'gender'] = 1
df.loc[(df.gender == 'Other'),'gender'] = 2
df

df = df[  [ col for col in df.columns if col != 'stroke' ] + ["stroke"]]

display(df)

"""##Normalization"""

def normaliztion(col):
  max = col.max()
  min = col.min()
  return (col - min)/(max-min)

df.avg_glucose_level = normaliztion(df.avg_glucose_level)
df



"""#4. Build Logistic Model

##a. Prepare data

### Create train/test set

###Create input and labes
"""

y = np.array(df.stroke)
X = np.array(df.drop(['stroke', 'id'], axis = 1))

X

y

"""###Train/test set split"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

y_train = y_train.reshape(4088, 1)
y_test = y_test.reshape(1022, 1)

X_train, X_test, y_train, y_test = X_train.T.astype(float), X_test.T.astype(float), y_train.T.astype(float), y_test.T.astype(float)

print(X_train.shape)
print(y_train.shape)

"""##b. Build model

### Sigmoid function

![image.png](data:image/png;base64,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)
"""

def sigmoid(z):
    """
    Compute the sigmoid of z

    Arguments:
    z -- A scalar or numpy array of any size.

    Return:
    s -- sigmoid(z)
    """
    z = z.astype(float)
    s = 1/(1 + np.exp((-1) * z))

    return s

"""### Initialize parameters"""

def initialize_with_zeros(dim):
    """
    This function creates a vector of zeros of shape (dim, 1) for w and initializes b to 0.

    Argument:
    dim -- size of the w vector we want (or number of parameters in this case)

    Returns:
    w -- initialized vector of shape (dim, 1)
    b -- initialized scalar (corresponds to the bias) of type float
    """

    w = np.zeros((dim, 1))
    b = float(0)

    return w, b

"""### Propagate

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoMAAADfCAYAAACNvdkrAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAFe5SURBVHhe7d1/aFP3/gf+Z7/sCxX8QgU/cAIOzHBwKwqmTDBh/uGRXjDFgQkOTHDg4h249A5mojCb+UdNHWjqYDNXcM2ESSJMGuFKM5gY/3AkBUciKI2geASFBCY0MKGBK5zv+33OSXLyO2nTNrWvB5z2nHd+nfM+Jzmv8/51+mQGhBBCCCFkXfp/tP+EEEIIIWQdomCQEEIIIWQdW+VgMImJvj70fRpBTkvRy92wo489PjGrJfSo3Gyy7vpzxW2w36h9hvqYHZFXWgIhhBBCyApb/TaDryKwv+8EIllMHxG0RI4HihakatJ7Cw/oDLfsyP7qQKO1VJ7jAMIvp+HYoiVq2z2UlDG2R0sjhBBCCFlhq19NvMWBYMSGqMNdUUKWPGeB73AYwR4OBNslHAkifDgK58liCSgLdFkgGB1PUCBICCGEkFXVE20Ga4Kl2QlYztoQvqQvbcsh8mmfUuWqThMspCpLnmNp5/Qp9dMqadXU2mS/EVGWK6qleQme7jn691NL/KLATScMTat7BTguhWFjz3PfyJUC3ey3Zu1xQgghhJDVseRg8PHjx9i7d68SKPH/fLlz5WApNMuCvks+2CLBcpWqErQZ4NyZAK/V5lNi3AdLVUDYGR5csqBsvPieWdhvOeHTHlWwoLTv/WnYX6qfyZ8TfmQpBYTCkWlkIzaAB3ayrgq4nlIJqKFOoEsIIYQQsjqWHAyeOHECf/zxhzLP//PlRdGCJZ+ZBX2oqh6ejbMgzY+EriTN/G2CpfgQX2znktkQnDf176kFpNoSl7xTHZRqzzkbWFSnD2GvXX3/w3aIzQJHQgghhJAVsuRgsBgIFlUvd0I44mUBHuA/WVlqlpNSLIAywqgtq8wQx4GU1Kgfb3N133OLEUPaLC85lB5BKckrVRHzibf1057RmRwiJ9lrD9tK1cWEEEIIIattycHgxx9/rM2pqpeXjxqsLR8J0k3AFslqVcT6qUWVcB3Jcwa1JPLX6VJ1ca8PmUMIIYSQd9+Sg8ErV66UAkD+ny93m2AcAm6y4ExbVqnB2pCxUcu75sFi3fd8JSGlzQJGGA8D0WeVn7ooSocYwJ8cA6+UVjvMAD7zUto8EkIIIYQs3ZKDwR07duD+/ftKiRn/z5e7bo+otA+06HryKj1yWaqoDc1i3GYD9G35lDaB2nw9e1wsINO/p1aNqy2xkA2Ok372npaKEjx1oOhyEFc/UNVLYsLsAyqGkSm2T6zcJkIIIYSQlbbkYHBlmDFW7Mmrtd2znPUjIaslbRzv2ZsYj8L5vta2747IlrUH62IB2a8J+Fmwp76nAdOHwkqbxZI9Y5CTLAw1a+/JJoNjqOJzS4Eqe6y22lcdOLvuMDJahxkebNa7OwkhhBBCyEpY/TuQ9BQevAVg1N8phBBCCCHkHbZGSgaXAR9DsGqgaHUwaBr2hRBCCCHrx7ouGSzdQaSIV+c2uccwIYQQQsi7hqqJCSGEEELWsfVbTUwIIYQQQigYJIQQQghZzygYJIQQQghZxygYJORFBHbDfhz/MYr4TR/28zEl/+lD9F4c0e9GYOgbRSyvPZesnHwawXNRSG/VxdxsCF7RjsgLdZnfhSh6Loj0cu+bt+rnJPnnvE5i8osRjJg/QN+HI/DeVoebL8wGMaHNv8vyf7LtvNn97VytfdvR9rxJsuMxVjoeCXmXUDBI1r38owSMv8xg6t82iMYNmGNpwj47bPtE2L7xYfSwBUMD6nPJCmEn3okv4rCcssH4HttHr9gJe17C5D3tcYURtm8tiH/mQ/KNltR1EiJfTALH3DAP5BE9PwMTm2aSz/H8bD8mP/EqAUz/HjfcmITz+rsbEBZmJ+C6Z4HnsFFL6Y7V2rcdb89GM9wngMnPI03uOEXI2kTBICEfuuEb7ldmpXQc/H4w9h3aCeKtEdZxKw03tKLyiJ22IcsCMJO6WzCwxQhh0wZ1oYIJ7n8XYBmPo6CldFP6eydCu92w8bFHC1n0H3BB3Kw+ZuQXDEhA0m4gNHDQA/H6cYSeqcvvlNcxeA9l4TphgrZLumZV9u1it2ezFZ69IRz/icJB8m6hYJDUkUP0s/0IPtEWexmvtvtyEuklnC0G/jEIteAvjwwLBsFO8ZadWlHgewJM/6gtFsw/jiH0VflWhqM/JZF5ra1Ejq3TpyzdsB/eazEkny1vXVfuT7YuZ0awf6eh9taGj0MYPRdnW7aa8kheHMXkn23upFdse66MQNzd3mm6f6cFjoshxLp+V8ckYhcKsJoH1cX+QViHdaVIvLpQcMJcuh27EUP75jB5M60tvztyd0IIHhBh2agl5CXEb0xg9FMvYo/Z8f75ftjZcZZ7EccEn/8+3ZUAbrn2bc32FPJI3w7B+/kIgn9kEDltx/7PQ8jk0wh9yea/jCoXiZzRJGLuUgTlvZxD7IwXoSddD1kJWTEUDJIa+dt+uK/HIb3s8R+3FxE4P43DcsFTKkFamgzSt9g/YQiDW9WURgZ2WOG64MeYUmSYQ2HzIAY3ayvxXhbSfTPGfplG4JgV5m3LW8csfGTF0P9lEX88BOvuqjLMHS4EhpOwf7ZaVVsSIp/ZEd8bgOej9nZSIZNCFAIMWglcS4IB2xFBfClXBPU8m0M8Z4Shwe6T7oVROOuCWAwoGMNWCzKxBDuS3iUFzKWjwBaDdtHEDBixKTeN4M0wRi9JGBDiiJ51wjKeg8Dn01J3LkCWZd/W2Z7+ARbKpzF5LQX/WfbY+0D8mg+iLYYN7FogfiuDrPZUCEZYnswgUbpYFmA978aG8yOYmKWAkKxNqxwM8nsB96Hv00jpqkuP3yGEl7xMzGoJpCQ3m6ybZ0v2Jg7/F0HlvdMvSj9/vYetp9cchnh1DGbdyXhJlJM/+3/UDK0sqLl+ESNfqsFX6E5CPfnxtm4H3ZgfD8E33FkQmLvtxf5/BnUlDu2SkPqNvWqXBdvr3Eqxf88YpvaG4TyXXJaq1MYKiJ+2ILx3CmN72o/W868XF7ZmX3f5eH2dAy8nrut1DJP3nbj8rzpHyh/ZVS6J7bY8cqWOHUUSMvfZMSfYcfmCiA28alw3bzIZWYiUQ+zkfnZMN5h+bP9I7+6+rbc97FLwQZD9NcJ7aQzGfKJy/pCJLekl2TppswojHP8Zw/xRl64TDCFrxyoHg2aMvQzDdtMJd3X1FvuyhRxR2CJZdiLRkohCuY0euxrvvgKSF7wIay3k4lKvtothQcZ5JyaPeuDcpiV1QT6TVk7+tp3GttsRmQ96YeIzV2JIsCAm8qUTc44YgixIaD/80byREL+T7zxgy2eQvsPOxcPmhiWkRpZXlrMeBB9qCSugcM8P50UnPEc763AwsLmz5xcZNhu0uS7ZLEDUZiu8ySB0Pg3nJYfSuaXGsK7E6Z0wAKG6pJwdc4lbgHXcA+vGOaRuVs3v5t8KAdZLd3H39wbTv5VvTlu6u2/rbA+7BEvcZmt8yg/3Lglz93MV8zZzsSlJkVhbcr1RhPt0Dp4LsXfsYoCsB6tfTbzFgWDEhqjDjcgrLY1JnrPAdziM4BFqur9SCn9OwnPHiuC4XU14nV+VH7XCi5jSBmm7gbfHq5xGeMPt1zFEvsvBvXeoYcBVeJVGRn/lXmDbkmeBljYsROFFEvGHlRcgasmACRYWDLZtlwjnLj4TxKh5Py5vmUKQneRWMhgoPIizTweG3kvDZ/2A5ZMB289WNbrvH4J4IonAr8vT0aJWHrHrE8idEDHUYVTcb7LAhQwk3e9BU/l5ZHk7z8GOw+/mtg3Buita6iCiYgH/yUls+GoMZmUnswuTa+X2ZNmcBGHPUHsly2tGP4bMLuCJVK6NeJxgx5wNzgPsu/IwyS4g2TxvT/mYz7tg+F+mO78dy7Jv62zPCxbcPhQwahPR/yqJGLu4cn3C5nPsAvGOCYP9BeSKX5zXWUiCGUN1LkSNu60wXAli+l3sRETeaUsOBh8/foy9e/cqJ2r+ny93SjgSRPhwFM6TWnXx7AQsZ20IsyvvciiYQ4Q3yi8FBhNIao9wyXMs7Zw+pX5aper3tFcEpO19ZqTiOUoD/lcR2EuvqXzPeq+pWEfltVXroUtTSgUdUeCmEwb98yo+s+o925JmQcw0y3cvbDu1q/BMttxOpqHqPGo2VedvLen2KETjCLz3B+A674dVGITn57u4G1cn/wED8sk4QixoM75fHXIVkL8zgRG2/hve9+s6lbAT9tlN2LTJhahygOUQO2vBfpOISV5SxgNFFoBO3+aPbUL/23LQ2JoJ4mdqCYckuDB5RlzxUqH0bJj9FTBgsMAbTeHutwZkzu3HZEXzigEY3heQ+y7etBpaOT7r7rvaqWnzjXyCBUksdz5sUkrG8px3Njh+2gs7C6R51eHI9+y43WyF41QCCf0gc7yBfzrFZjKYy+Qq9k8hnUDshBNii3aejbH3vjYK+6ejSgcCi1KNOYroKxNsX1ox86DYApC3f7TAeW8OoS+0qk7zdkQ2WrTfKQmpO/3w2szK0prUYJ8MDDvguZ9AStsl6QcxYNgK8xY2n5xGbpdFaWebe8ku1raxYOlNf/vfg+Xct21uDx9eip2BYGYXdnn2mVG4YeEdg15JSAoFdkFQwIAWj/IRB/pP2mGuVyosGNmFQAyxZK/WqhDSgLxEH3/8sczfpjjx5UV5GZZt7PX+ZFYOH4Zsi2S1B7iE7OfvP57QllnKOP88P3tEt6x7nKuXVqZ+Dg6H2ZyWErHp3rPNz1TWWUtI+pVl/Xsqz6leZs8pb5/6OaVlJR9scviluqioSlPWU/ee6ufqX6NtW8Ntr/X8qlUWTkzL83xBUvcF4JHvLigPN7UwPy/Ptzk1fbu/pmV2vS5jl0ee0TZuPuqSsW1Mvvu3usylLpmqtlcvJfsF9h4HpuTnWoq8cFceq077+67sEQR5LN7GBjb1XJ4+ZlT3O18nSUtuaaEmb+au8uNvTJ6pSp/XbXut5/LUMM+zMTlRfJ52HIpXS1urUI9vUZ56qiXU83fVZzeZFv6nvaaedEBmIXLV97hsga2jKJjlsd+VI05+/gtfN8iuqLos/8X2z8EA25utsO0/xr6T2ss6p+4/4eiUPKfkX0Ie4/tymH22cmjMyVMH3fL0X3y+uYXfx2TXL5V5vpa02ifzcY9svdB6j3TP0vbtsmwP+90YOxaWnzc89rXzxqm7zX/rCOkxSw4G1ZNg5bRY6smKvYc+0OGUk1s5CFOpX7piIFYv8KuXVlIv6NJr9zMr1rXyca46cKt9DaP/rEUEg/w9a066rbZPTwv+xH/55cCFgBz4xqGcyFsGDl32/Kqo7H+b/oSqbEflflTysNG2PZ2SRb4tl1KlH+OF+JgsVKWpAbN1idu3wNbFLJu/uSz7D/B1qg3AGipuVztTs6Beex8Te05pe3/3KK8rBVaa4vdLf3wuG+WYbhAM/jUju1lwbtXtD3XfV+1TaUb2fM1OvNpiLRbIfeMvXTgsRuqSWYagC/bYhYOnKj/lv1PyZfbdKAXbdSwkA/LYL3PqxdRa1OY+ef5fj+yJrETAu8R9uxzb83eC/TaG5bmmO1kLBqt/4wnpcUuuJv7444+1OVX1cieEI16wLxL8J/XVw0BOSgGHjVW9ucwQx4FUZYOe9r2SEMUQjHV6X3Jtf+ZO3muuQ9Wv2WKEDan220hVyEF6BEQdhspqvPedbPvakUP0LDv9XX2Omatj8JzywHPeq7WD48PLKE9qqpBX2+O1MzVur5ZD+r46xp99ny7Xefsc9k/c2F96bf97jXM89yDG1toE0VzswMG278oE+6tPYwpzSL2xwtJg/7dDuuGC86kLoTNuOA5blbT4TZZnylwLWxyYVi/GShML1tgDfrDQryJd/rZxtaNapSVA3FMePFepNhYcsO5eRIX1m/r7rd7UtCr9PV5xXU8BySs+BOGG+2hxnbXxHQ+o1Y4lW60I8E4a2mIt9r05PwZrx19AzasI+61Jwsr2n7XYGeAJ70RUmZ/YaIK7Ra/1/j0e+I9WdzJYK9rfJ8aDAQSONN4j3bOUfbtM27PRzH4bHRhcmzuZkKaWHAxeuXKlFADy/3x5ZahB0Mpajc9sRYJ0k4VQkWxlAKFM03C0CHaUMQWfjsLLfhBLJz8YYPhQncvkWgXbLNj6grfHa2dyIdoy4GWBsq6XXvpOGGkehO8tB3KGbbyPZx4LNZFlHqn7PAS2wLRDfXbhTgAelj8QRJi1NC7/WwTSESsW2y6dt210/mDE1CUXBlmQYNxrgxIO3gki1nmz2UUqsO3lXUdGYCl2I34dQ/g/OZi/HIW1at8vKMEbO5k1aX+V/L7efqs/Tf6pvaieLYNKT9z8mwV1uaiQwPTZNLvQspbu5IHXcRaws4B/eIgdeStH+i3EAmkR1uHysaUeb7r8XA96aJ90xSpvDz/iBdNg54UEhKyiJQeDO3bswP3795Xgg//ny90mGIeAmyzo0ZZVahA0ZGz0lWsRuLUojVvcZ7bpka4XG9eilFJ9vBEjjIeB6LNFNFhWxhSchv20u6rUQ4Cg9ZTL5Fp1IRHg+LU6CG00NQtOBZj28XCK5Y2WOfk/JuA+nYXjaqhiwGLBxE7giCMjVUeDGST4tQi/lzDfnjdJ+H9MqCVLB7U0RRqhG0Z4Dy2uhIOvl/MLYPSGr3yyYQGq8xCfYe99b6WGHFaHlMFhERZlPXhPVxemh6cQ+tqsC+5VuafsKBoWYWpy+Jq/rbff6k9Nh3wSTBAPAPGnUqlEV6H0NmUn5Z3FAKyA5A9+pUNQRcltF+R/82K74QOM1L0DS7Ek2lQOjl9E4D/Ng4hifnZLGkHrBzDsdCJU964+BaQv7ofBsL/BXVqW+niLz1/BfdIdPbw9LyT2rQScH71b/cnJu2/1h5Zpxx4Rfvhg0fWQVYaeYamidkIybrMBZwPl3qqzITh5iVAjW0TYeQ/maw168rbxmYtWMa5iEhNmH2wRF5TKQBakDrHQr7xeOUQu+bR5VWWgyoKxk3627ZaK3p3qgN2VvZ/LCsj9EYL3Eycmc5vQX8giX6zye5tH5l4QoWvqYoa99+S9Lt1NoAXjscuYOVWA78hxeL+0w/4zC7iSaYSrx+zbZofrGBCereoXy4JmJQzbKmDgLQuMvgrBeMGPER789Per7/GW9yQOY2Dc0/Fg1fknMUTO2TG014dkroB5XlXKH3hbgPQwiZQWj6e/8mLit5XIMyOsZ/1wvAzDd9aL4//0IrE7jPTPamllJXUcNesRUQ2Ol50R9n+5gOtJ9sk67/UrJTPxRxnkCznEv3PC+RN/BtvHmSAm73Qv1+ZfS5jPSWx/h9TBxCuw40HJozQyzwrIP47A+7lHuegyb13A9MUQMm/4411QKCDLguIc+wzfrapjtujtQuUFYrWlPN7q81dwn3RFD2+P0itZGIN1b++F0IQ0xa7we0htB4wyrYcsb5yrTNWdO4odC7RpPKEuN2t8X/Oe1Z0Smn9m7fu32YFkPFzxvvU7fxQfZ+uU5Mv6ddMaKbOp9Flag/3yVJs/75R0QDYLnopexnx/TR8V2LYbZfMxvzz9SOtF+KtLNkKQB/dZZeu/AvLM095s5j+fnJIDF2aadJhYPN6z0rTHr/WQXSkpObBHkD2/6z/0uTz9r0FZ0PZR+MFz+e63RlnY4ZADseflThtd81yeOly/VzLv9GHdBvbZVtn9A8v3NPueCUbZempKTrXRe7hTvGNPdaeeldT481d6n3RH720PP18IsuNX6jpC1p4+/ocFD2SF8HHcLEg07RRA2iPdYFf8mVHEx2urRIkOv0XeJ5dh/DkMx6LH4lskfv/oI3MYvePv3m0DOyBd9yLyob+j2+EtizzbB+MSHE07xCyj1f78buvB7eG/R8efjWKG/bbT7xFZaygYXGEUDHZTAZlro/Dn3Qh9rev9ScrepDF5MgzjmQBsKx0IagpPQhgdz8N91QPTSgaEbySkXxtg2rr6R0b+cQbYsXq9jVf787ut17ZHuu3FxDMnAux3iDobk7WIgsEVRsFg9xVeSChsNdKPcB2FVxLyghFCvbslrCQWmEkFI4xd7ZhBSC/IQ3rG263TLxBZuygYJIQQQghZx9ZGb2JCCCGEELIsKBgkhBBCCFnHKBgkhBBCCFnHKBgkhKw5udkQvKIdkRdawnqWTyN4Lgqp+l7Rb5IsPVabvta8lRA9F0SyZqxoNT3dY2NirzmN8vddOX56lHRrAsHZ6kxfvWOagkFCyJqSfyUB8xIm72kJKyUvIX5jAqOfehF7nMTk5/thPxdH7kUcE3z++7R6R5qVxMeQ/CIOyykbjEqP8QJiJw0wnIyhsNEM9wmw9YxodytaiyREvpgEjrlhLnbWfRLE/r79CD4xwvatBfHPfEh2624x605t/hZ+88JgYMc43oXjpzdJN45j8q0L7j1apvfCMc17ExNCyJqi3HHHJoclbbktz+Wwcoca/Z162ph0dxlKXTKxNEE2HgvLU9/wx3XzR6dLdxpaGfPyzAlBdseq7qmxMC/P65KeXxVl8epy3Ndm+aUumWXxP3PaUtmCbgP5nUhw6m7P3imll9XP3wV5Xpe/a/n46Un87lnDl+WaXF/lY5pKBgkh64QRjkshuPm9qhUuhKV5zM/XTtnMXUz9u3osUAmZ+2kW/9lx+YKIDc9Ykm7eZDKi9NYr4VUMoSsjEHcXB9XOQ7oXge9LO0IPtSTGaBIxdylSeY/oOgrFe233jCRiFwqwmge1ZbaOr9OI/TgK5+loqbSqf6cFjoshxJrevJnUqs3f/Is4ImdGYVfu5axq9/hpqJBHvrcOrFWVvB1AYdiCYq73yjFNwSAh60zhBfvx+d6Ovr4+Nhmw/2wE8Vl+U3/tCe+yzVYEbo7BpCyE4Dkbw/zAAAaqJuEfIlw/hDF1QHmiKp9B4hZgHffAunEOqZtV87vVd128PJIXRzH5Z3s7opBJIcrCT0NpIO8BGN6mMHFNgFF/txnBCMuTGSSeaMsVckh+78XITgM2bHIh+kpLXhYFZG544b3V5hnu2RziOSMMurGc+zcPIHs7iIRxsHwbOsGA7WDHcLqYbznEzngRerIaB3SDbXybR5qlj3w4wUKwHlEnfwfY1UzquxCErbqb/NUcP+3lb+6PSXg/2Q7Dhk1wtbvPF6nwJAIvC6YqP6WA3L1JOHc6EVnW47oTEubu52AUypne3jENZH4axcSd2saEjdI7tcrBYBIT/IT0aaRqJ6pyN9QT1sSsltBj+N1E+s5166ut5kVn28p+yGeX+iWrfA8lzxvsj96WZNuhzTag7C8lAFrBH+RZtl7aLF5FYO+zr/oPU/9WE8Qd2s+O4MTYaQfEPYMYWCf38+v/2IfguFrql7vuxOhPjVpEGTFy1KbNM48TCMIG5wGWdw+TCPP5YTb/mM+7YPgfC6i1p3ZOQuQzO+J7A/B81N6OyL+uXe/M4zgwLMJUU0SZRPa1NltBgPnrAHyHlvsbX2DfvxH44UbgUJvlp69zYFtTiQXk6TuA86NyaVZR9nVWmxNgPe/GhvMj7Pd0JQPC+tuY/zOCyYt++E5OIsZLk3tFvfx9kmZpIsSaA0h//LSXv8LHHgRO25b9XFKYncDIecB9wVYumX8WQ/DiJHwsaI08Xo2LgkZyyLHjt0JbxzQw+K8AxFk7nDcqv/eN0ju1ysGgGWMv2U/qTSfcN6oPmSRCjihskSzG9mhJRCeHyKcGBJa0/7vxHr2AB9KW2h82PRaIBc7aEH4pQ5bH2JG3AtiPVJ9Zt1ZbHJiWp+HYoi2vosyfYXXmoAVDK3m/4J7QD/OpIPza70rsC2fDk5qw24XALvUUk34QY4GWFWa2/9LJaeR2WTC4lX2LXrIv0LYspDf9i7wlYgHx0xaE906x37r2I/KBzbrSG4WE1G9pCHu3l0sYSkRdCWId/6/2f5lIP9lh+3sMoSO1a9bQZoGtdaXCg7gSkA8N1uaTYbNBm+OMcPxnDPNHXR33OM/d9mL/P4MdV4s22saBjxzwfOOFc6+W0Cvq5K/EjvG0IGL7Ni2hpPr4aTN/39ugzSyTZyHYD81j7D+OymN+mxXuU2NwWbXlniFAGNZmNe0f0+x369spiOwCtvL3qlF6Z1a/mpidIIMRG6IOd0WJSfKcBb7DYQSPtHkVSUgzryREMQRjDwRiq48FDffUiy+reZ3eWL/fhLHrU1DPFUn4Tvjr995jJxXPQfU0Y/o6Bfl3l3LSUebTHqW6WTg0hezTGQS053WqcM8P50UnPEc7e32/yQIXMpCKv5u5NOJ3gJHNC0jrS59fs0BVMGOo5gS/QtgJe/SLAvxfiOy01YFtQ7DuikLSlRMoFzG7BtGfk8qlsPl5ZNnJ1FJ9Mt0own06B8+FWGcltm8klo8dtp9c7Dauppr8zSF9n128HhjAwkNdpjc6fhabv10jIfTVcRTG3RDXzAWtEUPDJkRflPO3o2Oavd75NYuNvq6+WGmU3r6eaDMoHAkifDgK50mtenJ2AhZeinPJUS72VUqxitV8tVV99apsW1fjVr9nVRUeL9kpPaZO9poSTD2t2rs0ldexXvVrqyrZcrVmcSqun1qi57wJFkQbKt+jap0br2+T92Di+s+us46V69ZO1WfjvFEoVai6x6v3W/W+KD2ulgr62JzPXOd1jJLPZuUZsLDX8jxpZ38Uj5+Kba3JiwbbpZQKlj9Tqf6vU03cNB+Lz5+tzJuKpgRKvnRY7a1VS/CrfdGkv/JcIwp5pNMpNpPBXCaHwmLHQdvmwuWI9hvzcAK2L1djCI08YtcnkDshYqjqd7/wOI7QxePYv5N9P23Fdcsh+jlb5sdFwQrHqQQSxUHJ2AVPkp0Usm82VFz0SOk4+k/aYVaGnulALo7JL5wYPTuJydN2WMzHMaldRJS8ySBy+ji8N9LIzAbh/HA79v9zvzr9qJ6W0reCiO2yNglG2f68Ngr7p6Pwfj4Ci/L6UURfmdg+sWLmQUZ7Xg7SU3a+eMv2+WZj6SKmkE4gdsIJUd9OUmPcbYXhShDTy1w923obV17L46cmf1nQx35IjLkCNmwtn3mbHT+Lyl+2/+JsvZxf+TB50Qu72YLjF+PIVXyPefvZ40p65kmU/bZ/oB0XbDoZU3+DH0YR/M0E6+7FXYQtr0bHNLuQPOSG9fcU+/XiOj+m+3ezIHw2gOl7lZcrjdLbpvUqXrRHjx7JH3/8sTIEA//PlxflZVi2sffwJ7Ny+DBkW0Q/SENC9lcN8ZAY58M6+NkjumXd41y9tDL1c3A4XBoOIhuxld9TWR+bHH6pPKRQHy+nVb5/g3XU3l95re6zuMo09fX+pLJQ5/nV61ubTxXrr1DfszIv9Rq9hz5N+9zSdlUvM8VhPnR5Val53qivL297zfNr9kVlXtUu16F8RjlvWu8PbR3rfE45b9rZLt3+qNiO6v2pfb5+O7XvRO1z9Pt4Ee6PKdsFwSPf/VtLa6KYD+1MTfdBT9IPNyPIjsgKD6ExPyO72WebLqW0hGrz8vQxvm7l42L+vl82Q5QD6QVZ/uuu7DkYkBu9Wv77rjx2LCw//5+23IC6j3XHnhSWHYIge37XDTEScchCRR4tyHe/YXk3PMVyUfX8Z6uSj+XjICUHdrH3PjHDtqSe52z7jLJwdEqeU47FhDzG98Uw2yblo+fkqYNuefovPl/Pc3nqGPs+1H9z9oWZlh3s/Wy/tL9fO/+OtdpGTvu+L/W727EWx0+r/G11/LTKX+23vfybqX7fBP2wKcqxBnYMsM/RktTjiP0+aU9aiI+xY0//PsVhntzyTONMrz2uV0SrY5rlOts+d7TRirc4ptnx5mf5hW+rj6RG6e1ZcsngiRMn8Mcffyjz/D9fXhStuthnNsCJqurh2Th88CPxbbmll/nbBEvxIb7YziWv4pi+WVn6KByZLrcnq9O+S9hrh645eaW66yhD/lVfutk+ZV0qXitAPNTw0xl2tXUrCn9S3x7OjLGkH1FHqLOSI7Yd3lL+a5/7SFKvxpR8q9xO7BlDYjwK57UGn9Iib5J3fGABla5tqLreOBtX11up4tVjj8vyyrQlPRyGS7de4jgQfaaVHy1ln9c9/tQS8un7laUv/pO65yjHYKpcNbgISts3rs32guav6w+/Um/yfKS9qAE+fEm+jam6tK9cetp66gxv+xSGR8lg9h36La0e5yvlRQYJ9s8oNCqhHYDJzFt2ZUoN+Af+MYjtB2yw/qMf2Cwi8MMgwifrlGq+SWLyfA5OdoypA1K3q4D4VQ8iORfsw+XiSuMRL7y7coicDCGuFD6kkfyO5dbGcrsw414bRJaDqWLdYz4LiQ9zY9hUtzlC+nsn7L9ZEbzkwiA/FgsLSvWsaa8Fag3ZIFwRF7JnJupU47PfhTMRGM6z37xGbR2UXpnsO8t+v+qXlxRqjr155XMWMF+Vnm80CHCLbVyMdr8nrUcAaHH8NMvfdo6flvlbqXAvBM/1HFyf6KrTtzrgPWlC7roHIaVUK4fkb/w3qh8btCf1s21wsv+l317kkX3KS54N2NS9TK+fxzVT8y1tfUyzXD82DdcrLyb+qH6vNo5pts1G3v50dq7qO98ovT1LDgaLgWBR9XInBPZjw0KAipMfl5NS7KRsZD/beuqJufSj06m225DpqgHfd1YFJWX117ELdNWjBkejT+ckSDe1qtLi+vJJqarsULPtUPJNrfrUf47lrPZ4Hc3zJgfpEbt221b16B6RHQta0LPHpTYjeF/7vKZV/122s/HYcUva53WPPzXwLv/gcbYut3PUxspj+FAobf2ObqwdeqXR1N806GAnl02bsKmNafJP7SUaduHa9tSxjUYM8R9RwY3QJV2PxJVQKLRs47OBj/fBT+Z/qSeO9PUg+k84SycWbLUiwE/Y2mLJRjM85x0Y7PhkmUHyGv9drW78b4LlIPuXYxeXj/my1hj+FvueFs9p/RvYMSVgsDh0xht20lbnar2KsN/6JKxn3LAWOycovVnZ92CPqRwsbDTBfZWdHGsuXIywsZOmtZ0d9iLHwoc6XkXhqjr2tn/Bf2cnMFKVvun7Br87zbZxUXKIflH12Q2mdoZsaXn8NMrfTo6fRvlbJTMbUi62NlT9TpjMvPVuDqFZXnnKjiClejSJuWL1MzuuNrF/1i3Fnc2C+Lq94xcvd8tVN49rJnZ8NMz1do9pNmf69xTGPi6nqDo4pu/k6q9Ho/QWlhwMfvzxx9qcqnp5+ahBxLIptWGzIBXJqica3vNZe3i5Ke3X+OebU1oPWBnZSJNPZ8EFb0XlT1aeGNVJX1q4NEoAxEvDaj6DTfrSwqXStkclwPGr9hlKiaFFzZuVDApXiPSsWcDfBdpYeUp7wd1tthdkJ7v6V8i1U/P2e2qJbs1xU2dayREEpBs+eG6a4b8VKP+ArxR2Umz1uy+8z8te2En8BQs5XkQQSDvgGe44wutIv7JSWcxXn+GVXscGLeg3wjnuhyhMwncxqQQD0p1ppI8F4dqnneTe69edACtJv4XYBZEI6/Bg6TnpO2EWHI/AYmr0qi5TaoAqjz31d7bOb1yj37cm27g4ut+7FtN0Gx0sV+P4aahf/c3J/lV1YGm9jg1KRvZD/HIarm1x+MYjyr2R8/dmMLPPDx+7+C7q7/IhotYM1s/niqlJzU9PHNOLtORg8MqVK6UAkP/ny90mGIeAm1JV0adaEjZkbLRbWgSLW1gE3qS6LXd/GtHDYWTZzi994ZTSnPrqr2NzjU/8apWvTQlCy1XVTQMFtj1sDRZfUtomZTs7rKZsnjcCjDv1xf+auiVnzJ4x9Qupr0bukk4DscXs85K6x1+DUtIl4aUM22Ho+wD262xN2VXqNE/eZYZlW3s/Tsnv61wdN5iqS/R6HR+jzOmIQ4yEOxrWpTN5dpKYhP1DX+3xumWQnTrYM94sqMv1CPxYAeIvk4icnYHljBPGZT2vDMJ0gP/mTSOR1ldj5THPi8AEOyy71JT+PW54jrnh/GgBqXtx5PeF8fxnW7mUkq37dv5Wf6tVZWVaz1WYlOF5FCxQ8Z9OA4dFWLoYlPOcFUyDLYPuRWu4jT1imY+fTvJ3cJdVed50MlWRV/m/lAMLdrM2cPtWKzwn3XCx41Bix0nG4EU8ri+9ZOeNQf5O81jomUxfqWOa5Ti/6D6qG6Ra0Si9PUsOBnfs2IH79+8rJ2j+ny93nVJl6INFVxKkDD3DUkWtBMG4jR3uZwPl3pizIaWnbENbRNh51aO+nVt1b0/9iZ4/1qzKVVvHgL73rq6npxo4OBEqtnFk7xdoUrXK6QMkXlJYWRVbHUSZ4ao7RE9f3d7AqgaBWDPFKttiz2+FWpXesOdyi7wxD6ulfeVesuz9eF6Pi2qJpvLcyp62ajtD7XF26BsPdxYIL2Z/1GixXU0vOIrHny4fczfYSfWmDfa9XTxtvZ1D6qcM+4wF9L/NI/bfy2xegOMrF0w11W71Ke0gi1fFLaY1NSbo6xi8h3yQToQQbHv8uwyCYh/2Xyn2wGwt92IehVcJ9j3TEvQEE8QD7ET9tEmbK4F9T/n/c05Ms++FS2nrtZx4yUwQDiGHiSvlW2ThBb/9HTt2fnBp37sC0t9Z4f8/J5z7RIhsMm2tXrdBmI+x4/mhVFWV2o9+5fhLI/OsgPzjCLyfe5SLbfPWBUxfDCHTqI1eJ15IbI/VH9C3exptY49YzuOnw/zt3zeK4FEBue+CiJbGJ5QQux6EcDRYap+du+mC+EjE6EH1uDL/Y6Cm9HWQnYsEdvx0UjCxvFbomGa/4HO3AHGviW2/XqP0NrEf8B7SrFdosTdWcartlVXR63E8oS7re73WqH7Pyl5Hlb0o+WOVvUlr31/rXVqaKtdR7aWmPXY4LCcqeq9Wb3vVe/HnVffa1Xpq6T+n4jOKr9Meq6vqPZTXV72mNq063yp7edXXPG9KPWeLU9V+a7VdpccbbW91z16m4j3Z6yr3R739Wy+t2XaV80nJnzo91GuPMe0Brs7za9LqbFe15//1yNZtkM0HrPLgDqvs+TnVpNfjeqH1It7D8q5pj2reU7Qqf/+elxda9M6tph5rY3X303zUJUNotg/VXoLl3ondtCA/j0/Jbt4blvcU/uGu/Lx4cPyVkAPHzOy4cctjF8Zk10GXHLivP3Lm5Zl/G7VjVzcJg7L11EypZyi/Mb+p+jhmFpIB5bgU2DHp/oE9P82ObcHIXjslpxr2Hu7M/H/dbH3GSr1S26Huq+bfqRoNtlEx/5z9tozJLIBm72uWxyIJea5L29ee5Tt+muXvgnRXnjrBe/zyz74s331aPHbm5cQFl2zew/b7twF57F9W2XUhUfGblPpBVHoPVx5bRtl87LKcKm2D2ou77rnnf1k5Fbus9FJWj+sZOfWyg4NgkVbimFaPNas89VRbLmqU3qYeCwYJIWS5LbAg3MxOYg45LGlJjfAf2KPT6gXCwryc+u9l2X3Y1fp1VZoFg8pJbU/lMC4V+NAb+9gJd0UDiPY8j7hk1y9z8jwLeFLxu/JdZZqWL7Mg0v3f8sl/5oQgW6+2P7xLd/CLMRYI/Fr38rCh+eSUHLigC2bbslrb2IZlO34Wl7/t4MPfOM7flbPzWXkuWTyuZuTwN1bZrBuGiQejwoHy0EbvPv7bZZLN51PloXkUjdLbR8EgIWRtYAHH3YifBWMeeeYRL7USZds4O2FId2U/n2cniXZ+CBfuj7Er6NYnsYWXM/LYHnaVz35gi55fFZVSPCXlwWVZHBYbT7qTVvNgkOEn7D3s8WKpx98pOXxhSr6bYdu2T5TH4vpyk96gnIgPlceG01v43aMLBpm/E7J/j63jIHop+LiI4nhi0SfHjq3CNja0AsfPsuUvuwDjXc3qfleeTinf8zL1wq6TcSTXsoWkXxZ14zEWNUrvBAWDhJA1Qx1oVpCNx8Ly1DdqFVBpvliC14w2wG1l9VPzqRw08tIflqYfMLdNLYNBZiEzJbuOBNRqMPbjrlSTCVbZX1E12zvUfWGWx2LPy9XmC/Py8+SU7Dk1XXti+uuuPHaEBfIrECzxphEuFjSseM6t4DY2tczHz3Lmr1L1zC/WrrL3L37R/rcgZzMzcuBEoE6zjnn57rcO2fPfdzsgXGBBsutr9r2qaqLSKL1TFAwSQtaI53L4ED/BueWZv7T2mLr5xnfx0CykZP8e9hpdoNd6MsmBdPH1d2UPS2vdPrZWO8Gg4u/n8nOtOm9hfr58MuxF/3suz4y7ZHGHdgcXYVAWj3nkqXiz/GHBorTcG8U+o9Q+bTWsxDa2tnzHz3Ln77yc+tkt2/YU26MaZfNhtxyIzrFHGpt/yi5KtPl3DwuGn9b7XjVK71wf/8MynBBCels+htFNI5CuPsfMUQneDfuR0c3335fhbzLMaeFFEgmpyRAudW3CdrMJAu/K+OcEDLun4fo1BNewCcZnQew/02Q4ogMB3P1aHSqDjwZgcAyCdzdqMFodIYSsGgoGCSFrwx8+9O3NIPxyGo5XLDAzpzApsfnXPEiT4It74Nw32LVbglXL3ToO05cJjFyawVTbQ9EwbyTExu0YuWjE1KMQnDtqh8kghJDVtORxBgkhZCUo91QetsK8hc0np5HbZVEGd829lIBtWUhv+pctEOSEQ1PIZuc6CwS5jUZYL6TAB5B3USBICOlBVDJICCGEELKOUckgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6RsEgIYQQQsg6pgWDOUQ+7YP9Rk5drJI814e+c0lt6d2Vm02ynNDmb9jR92mktNw9SSRntdkVkcREH9t/fOqxfbh8ebxGvIrA3mdH5BVfUPfThHZstMqb3vxOVm4DIYSQtYFKBjX85Gu4JGlLy4WfLC2Ia0srIXcjAN/hMLKyDPlbs5ZKesIWB6blaTi2aMtrnhlj7Dgb26MtEkIIWRMoGHzHSc+iwE4jBG2ZEEIIIURv0cGgUk1VrH4sVXVplOqvCUR4VRd/vFTdpVZHl183gZYVXbMTuuerk746m6+H/UakVBVaqqKqel2jKnBOKRV0sKDpphOGqm2J67ezTrVd03yooJYK+ticz8yeey5ZpyqwTnW9sh26fGp7u9T3spxls2ctleum7J/ye1RWN/L1ZM+9Ufwc/tla9R/L5/Lr1PdTtqGYVrEt9aoM66XpVK8XnyrWrfr4aZLf2nu1/Pxm+VlRjaupl1ZUva+Ymupc/eubvVdbpMr8qKk27uz7Vq9qujZNzcP671mZv8Vtr/iOVH+HtP1UfFw9xnR5suQ8IoQQ0soigkEtyEACMq965FNyCM73q3+wfXA+86qP/+qAoJwoDJg+lC29LhtJwdLsBMVPBOYUwi+1z1FeY0PU4a74rKhjGkbtObyKSjmBmYGE9hpZTmDIYWgYOAlHppX3hVKdqqu2Y8Hh9Lbi+mYRBgsWSyfcdvOhiFehJeBnc/4ke+63Zgh77bDdnEa8dOKLY/om255n5erq5B0WPo6L7NXF7dLlx8sw0HC7BDh+lZEYZ7PjfB217eIBy/tODPF10PLGz4PFikAiCucto1q1LI8pn835HBK82rYmxtlz3u+DG8Hy+7D8cjcMTlthx0fFerEpyXKLrVs5uDDAubOc39kI4DxZFVwUbRFhP8zW+Y5uu2bj7Kj0Q9SqMTvLzzbsEdm7+xAvBZtJxHkw/kgqrWPu/jSih+0Qu1E1fNYJ6aS27tp+LK/7Ir5vLfFj3oJUpPyeiXEfLDVBqA5bp/iwbh0rjhF1n6P0fgmW/0529Om8c1XphBDSeyqCwSg7EZau4HWTUrpUpAQsfiT07c/2jKnBwbXKk4J/WPccfiJmwVbwSLnCUjgSRPiwD4FGJ986JwIlgNLmSypOrjnEb0VZwFUOYpRAjAUWUUeowxOhH97S+goQD7FPLp7YO8iHhpSAJYrp++r280ABkTA7qce19VSDCTUf1e2yRYLl/GD5E+TB8a14KdhoRQ0uE7p2XWreoPSZKtshsaZq2RZxlfLUPKyEtbr8McLIgq/Fq9PeTAmuinKQHmmzGh7Eqxca9Wj7S7dd+sC6W/lZyQyRBd+lAJQf8+NhdhFRDPi1z6yTt4tSZz+WjvHFfN9akiCxixU987csiGvWFpWtg0u3jjx/ihc7xfas5XXUjkVCCCErqiIYtOmu+PWTUrpU9EpiV+4+WJoFjAobjLogLieltGpY/esMcFadXOpTq5+U17xfVXLAVbSJU09YSlWs/rPMvIK2Q4dZgKPN1mg7H5pRA5biyZG37xsyiiyo0kqX2GekSiVZ6nYNGSvDCLV0kT2mLTenBlS2bVVbpQRdKUi6Es3qz+HqpXWfvmpTrVZXCXCcVEsK1cdaVx2qFw7Fkjp9YM11Iz9rKUGydsHAj3nbNrY/dxYDfv6ZNtj3dicfa/bjFiPbXnU/Lu371ogZLqVkvnjR2EYpY5P2qnXbsyrbQAghZCV1XE2snGRY6FCugtVNTUoIlB9+pRq29nXTutKLCqX2RLqqqZfh5icLJYBia6ivbixN+tLCpVlsPlQTjENa6RUPVnjgpwaIKSmnVimWSrIaUILSJdLybHUVA359VbBarV6yZ0xLzyJ8WK2mbhoUbnHAWyypq6oibmip+cmDGaXqn5cCQgn8eICoBPxKaV2XqohbWNT3rQ1KaazyPnzfFC+GllL1TAghZLV1HAwqwUtVKVI7jNtYCNdhiYvavko9oZVOYK1O1uxkrKwhC6aW02LzoUaxndk5XqWoBn68dAq3QgjxKsVS6Y9aDVu9XUpQ2qwEs4IA487KNokKJU+HKkpyl0WzoFML1pTguhhMN3y+2h6yGBQWq9nrKZbURSqqiLlF5mfL40+r+r8WwjS0wI/vYxbwT/B16GLP7mb7cTHft3qUoLIutVq/GBSW20m2T1lHXXtKRav8JYQQ0nWddyDZ41JLZSoa7qulOs0a3gtHvGpJgr6xuVby17B3Kac/oSkdSlpV9xarsio7mSg9Gqt7MuoowV0nJ89F5UO9AERrZ3bWVw78eEB70wdfRZWiVqWs3y6WH25HZ23QlOBI1ylDWWeep61KIDumbqvvUjl/ktfqVPFX0AfXbL0qmgRo1ccVxw9vt9mi2pUHYjedcFZUEXNt5KdyYaFvA8rW4VKr4097X7Y/o6XAj+cF258167BEdfZjsV3nYr5v6nfAiVDxcfb8QEWzhzrHd7slrnUo61jdoWQxzTkIIYQsSefBIDu9OX7VetayE0OxbRevxm1e/cRLEtQej6U2TFrv0UaD1PIqKaW3Yun507C/5CURzUuD1N7B0KoR1cnyKIxsw84GjFZCxz+raXBasph8KAYghorAVO2MoQ9q1ACxsmOMul1qj2Xt87SemB1V+/Gq1pdhpEptKi3w8d7GHVRtt4fnD9tXunZr8WG+7xpg61W5zywsNuAlf8UOGdr71Rw/rXqaanlZJ2BpnZ/smOXNEkqf6QZOtmimwBQ7OZUDP3W/11uHJRkPw3hJW/eaY6/z75u6D2zl9rYnAS9bLlPzg/e4Lr2n0ht7sc0vqt+P7fNIVf4qASwNLUMIIcupT+YNgAh5h/FSYWUIoK4HvKTrePD3Ph/CqHvtewkhhDS3iJJBQtYS3jHHhvAxCi16jTLOY0XnkxwiJ52tO00RQgjpKioZJO8sHmzwO8vwIZM6qkonK0YptdW3S1yWJguEEEKaoWCQEEIIIWQdo2piQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghhJB1jIJBQgghpJtexzF5ZgKTF304/sl+HL+YRF57qFrhdQbJ614M9fWhj00ffB5E7F4a0hvtCT2lgNy9STh3OhF5pSWRd0KfzGjzhBBCCOkqCSHrB4gdzWL6iKClVXkWwv4PjyMOK6aezsC1TUvvJc9iCN5KIx31ITRrQ/jlNBxbtMfImkclg4QQQsiyMWLkqA3RazMsLKwvl46zQJAZFjHUqwHWNivcp8bgsmrL5J1CwSAhhBCyjATjEHAnjUzduuIC5h5ElDnhIxMG+5VZQlYUBYOEEEJIN+UlxK75MPr5cTi/nEA0nWWJWeTrtgPMIH1HnRvZPQSKBclqoGCQEEII6ZLC7AT2D1oQzNvh/3kK4QsmxL8Mao/W8SKDxEM+Y4V554CSRMhKo2CQEEII6YZXUbgO+TB3KITw1yYood3GTTAoDw7BWKc9YP5RAlE+08vtBck7j4JBQgghpAuS19yI5EzwfmFVA0EuPw9eSYwTJgwqCZUyD9RSQ2EXtRdc75Jn+/DBpxOI/BZH8At1qKHjV+KI/xbCqLkPQ9+ntWd2HwWDhBBCyJJJmLufY1GdHeIuLYkpPGAndvbfNWwpB4glaSRuq3MjZmovuL6xY+HFFO7+OgbHge0wFHiaA9ZDIsQDLvi+csBuNinPXA4UDBJCCCFLlkfuEfu316hVC3M5RH+aBHb54TrAQ8EC0t+P4IM+A7afS6Lwqthe0AbRRO0F17WCAdZxJ4zK/BwS19n/XUMwakNT9u/2wqW7yOg2CgYJIYSQJRuE+Rg7c+cXsKClSNc98NwX4b/igVkp9ssidScGiQWJAwsLSN8JK+0Fzd+4Yd3KHyfrVr+Awa1a2fCTtDru5EELimWBA9tMEJax6JiCQUIIIWTJ+iGejCKwOQTvyUn4vrTDm7QgnL6LsT3Fs7gRzvOX4dghQJplz7k0D9eFGYTPiHWqkHvM2xzSvwVx+T98IYGZWzGkXyl1maTLcpkEeOtAx06lnHBl8NvREUIIIYQsl/lHM/LUv8389rdsEmT31YQ899eC+mA2IQcOs3RBlD0/z8iJp/NqetFf7PETATmlPb2Z7K8OWfzPnLa0vOYf3ZWnz1tlQdkmyKZTYTklzcvKav4vK6diAdnGH9tmkwPRu2x7WfqjKdk9fleu2kKdBfnuKf5+ojz1VEtaAVQySAghhJBlNbDDCtcFP8aUNnA5FDYPYnCzVmL6XhbSfTPGfplG4JgV5m26ctIXETg/jcNywQNTq2rS1zH4v4ogLmWxEmWWAztE2L6ZRviU2rCvYBiEaeuA2hHoPQEmA5AVHJi6HYbnkMi2l6XvcCEwnIT9s0iD2xMWByE3Y/sK3qOagkFCCCGELL9+ESNfqoFT6E4Cyt353iQxcdCN+fEQfMNVleVv4vCawxCvjsG8UUtrqID4BReCOTb7UFKH81kR/bAccIFvVeZkDEk1Ud2uE9MQfwnC9Y/KKLZ/zxim9obh5J2ItLSS4iDkJyx1hyJaLhQMEkIIIWRFmA961U4RV2JIvJYQ+dKJOUcMwX8NVg2tw4K7805MHvXA2UYJWeEPP7zXoQRluCNBeqskr4j+fXZ4lZ6+Psz8wf9r2/V5nQBXY2TbZTnrQVDpTa4q5Hm7zGl1EPL3Cmx55dpkUjBICCGEkJWxS4RTCZyCGDXvx+UtUwj+W7tbi97rGCLf5eDe28b4i4U0Jk/FYf3BD7uSkENeKXZcKSaIDrXf78TvMSTPOdXtqglwdfqHIJ5IIvBrvFQ62D8gwHRimvflgPyDDcJAyy3vGgoGCSGEkLVsdkK5W0Vb07lSReYqYYHTZ2rgJAkuTDboSZ1PxhFizzW+X79kTS99xY3pvT54D2/XxnicQ/a1MrNiTMNOtcTz3AhsT10ItewhPgDD+wJy38WVnsOrjYJBQgghZJHqBlxdnlr6yIP5+fn2pq/N2osaq7cOnUzNSZAeacV2f6QgNQjapGcJ9tcIA+900cyzEHwXhuA7zW8BKMB4iCcmIb1sUcVayCOfb2dqs6p2s0EdMBoivCedGGzZxhEwbLWwv0nMPVOXVxMFg4QQQsgiKVV6yzy19F4/BgYG2pvaCFLqrUMnU2MFpQo1IHjgP8CXowjdqd+ntvCmnfIyCZEzxxEbLCBzbRKTF0OY0d4u/aJ5F5LcLRc2bdrUevoiCt4npZVCJqW29RPMMFV1GGkujtwKl2LWQ8EgIYQQspa9LdQp0WowvdFeswqkGy44lSpUNxyHrUpa/Ga87hAr/e+pvY6byd30wYMpPI9NYeyUB55Tfni1Kui4VD/ILBKOaG3zWk2/OtROKS1k/gyrMweHMLRyTf26hoJBQgghZC37c7J+qVa96fvVaTMo3R6F8wcjpi65lCpU414blHDwThCxx8pTKhi2iexvHguNammVMQUljJ50wqgLvgyCdteOZ7m2SvS6Q0LqnvppVnOdzjANLCg9nh0Y7IFbEVIwSAghhKxle8bql2rVm75t3Waw2/J/TMD5BTB6wwex2AaQBXtOpX1fGqF7GSVJTzCJLFiMIyPViwbVMQWnD3nhLt3qTyUI2uh8j7IrN9bgqyRiykDRIkQ+0nSbck+jwLAIUztFj8uMgkFCCCGEdF3+SQyRc3YM7fUhmStgPp9Xh1F5W4D0MIlUsX3fV15M/Capg1AXbbPDdQwIz1a2HSywwCt0cgTOizls6i9U9BrOP4kjeC2kLjzxwv99HNJyDjFTyCMzG0PowmW1vSALXhP3Esi8bqfTSRqJ24D1iKh1PFldfexKoY3WqYQQQgghK+jhJCwHsvA/DUBso+PLWlKYnYDlayB0b6z1bfZWAAWDhBBCSLe8jmPyUhLYtIDMffZ/rx+BU+a225GRStINJ5yZUcTHza0Hn14r+K3qPrkM489hOHqgvSBHwSAhhBCyLCSErB8gdjSL6SM90DBsTeLDxozCn3cj9LVp7QeEb9KYPBmG8UwAth4JBDkKBgkhhJBlkrthh+GaFc9/d/VE27C1qvBCQmGrcc2XsBZeScgLRgjvaQk9gjqQEEIIIctEMA4Bd9LI6DsyvM0j8zhXuictV1DGASymsMfvJZe388Ma0/8OBIJc/5beCwQ5CgYJIYSQbslLiF3zYfTz43B+OYFomg9wklUHe85nEPpqPz74fzfBeUvrSss9C2Fk0yaIP6bVAPHPIETRgg9ORyt72BKyTCgYJIQQQrqA9xDdP2hBMG+H/+cphC+YEP8yqD3KDAxiZK8ACQLEPeX2b9L9KOL6tI/GkLhqBV7NY155xuooPI4jdM6J/eJ22H+SkH8Sgdf6AfoMTkRfsSe8TmLSsR2Gvg8w8af6GrI2UTBICCGELNWrKFyHfJg7FEL4a+0uFBs3QR2CeAjGLfx/AXMPIuz/CCyl8UQkxG/G2H99GmDcaYGwy6i9fnX07xAhbi0gfs8Ay0Ac/quAZZ8RyEUQvx3C8a/iGBwWkePbkNaVdJI1h4JBQgghZImS19yI5EzwfmEtt23Lz6t3wThhgnpfjDSS19m/wyIs2p04CrMRBH+rTOOkRwnYzUOr3Hs2j0ySD6c8h8CNPJzjDpi0jQtezcD2wxjELXwNBZi3rWbYSpaKgkFCCCFkSSTM3c+xmMgOcZeWxBQexMEriV3DFjVAfJjANHuauM/EwidOQnjcx0JEwDps1tK4NKK3THDuW+0uExmkb/H/Q/CedcO0MYf0/ThbNsFz3gcrC17Ts2G2PIKhnasbtpKloWCQEEIIWZI8co/Yv736at0coj9NArv8cB1Qgzpe2pdmgZRoUgeZka77EJo3sTkR4u7yK/O3Q8gcdcG82nfd0IJX0ykPXLtYsFeYQ0Ip2fTCrWyTFgQfMMOkK9Ukaw8Fg4QQQsiSDMJ8TGBR3AIWtBTpugee+yL8Vzwwa4VmuRe8ynUThM39yP8xAW/GheBXvAJ5Af396pPyj0PwP7AhcGT1RyXMZXjwKsLpKJZsJsHLAV1HrOqYia+SiN1hoezw0Kq2bSRLR8EgIYQQsiT9EE9GEdgcgvfkJHxf2uFNWhBO38XYnnL1qemAH2bE4Ts0Al/ajOC4CNPBUfj3SRg9aMH+T5wIPNgO71mxB8bUyyN1nwWvggmmbeo2SI/iyMEK80517fLpBKI8EN6aRejHZMW4iWRtoTuQEEIIIaRKEhMGC3wHpzF/1caC0xwinxrgzAeQ+q8HvONz7tZxmGxxWC5MIfi12JODKZP2UDBICCGEELKOUTUxIYQQQsg6RsEgIYQQQsg6RsEgIYQQQronLyF+YwKjn3oRe5zE5Of7YT8XR+5FHBN8/nvtHsykZ1AwSAghhJDuGTBiU24awZthjF6SMCDEET3rhGU8B4HPpyXktaeS3kDBICGEEEK6SELmflq5I8vlCyI2PGNJunmTyai72wrpBRQMEkIIIaR78hkkbgHWcQ+sG+eQulk1v5vfdYX0EgoGCSGEkKYKyFz3wXdxEpOnndj/iReRJw1avb0tQHoYw+SnfejrY5NhP3w34kg+yfdWO7m3eaRveDHy4QSSWlLXPE4gCBucB4zaXUvY/DCbf8znXTD8L0PVxD2GgkFCCCGkqX4MHvXDf8oDz4UwZv4NeI5MIlkvunuvH8ZdIkxb1UXh6Bh8R0SY/zHA3qU35P+MYPKiH76Tk4jxKtwuSz+IAcNWmLew+eQ0crssGGT5kXspAduykN7098AdVogeDTpNCCGEdES9O8f8LwsIDNcL8dLs8SH4coArOo+pQ70Y+mh3FLnpR0Ieg1lLJesTlQwSQgghHTHCuBeIP85oy1WepRBngSB09/ElpJdRMEgIIYS0kJuNIHh6FM7Pj2P0xziyb4H0m/qtAPOZNOJ8ZljE0BYliZCeRsEgIYQQ0pCE6OcfwPB1AoYvLyP88xTc74XgvaU9XEfmQVD5L+wyYbBXGgoS0gQFg4QQQkhdBaS/c8J+TUDgymXYtE4hmwbUql/bNqPyv1Iaidvq3Ih5qGc6jRDSDAWDhBBCSD2vovCfSQLHvHDt0tKYbE5if02wDNYZOvlFBomHfObdby9Y+MOHIT58zpImOyKvtDckq4aCQUIIIaSOQiaFKPvvOGDRDYUiIfVbGtjlhKgLEIvyjxLKa9ZDe8H+j30Ijlf1Q/6HDZ4LAQQaTmNwHxxckTuQSLcmEJytHdFQSf+zB0c6fCshei6IZM2qqenp5VxlPrQMIYQQQiplf3Xwoddkf1JLYBaSftnE0myRrJrwclp27RBkbLPJ4aeynBhn8+xx07cJeUF9Ro/KyuHDYOvqlxNayuI8l6cO8PcpTiZ57H7rLZ+/75dZGMmez/LtpZbYRc8jLtn9q7aPuMxlWYQoX86oi6lL1rbWc+U8l8PH3PK0Li8WYh5ZEDzyzN98KSUHDo7JCWW++6hkkBBCCKlDMImwsv/zf2u9hvNJTH7tQ/7YNAJHtLKtpymEHueAN/1YeBPDzH/YvOCA+zPTOmkvaITrP2E4SkV9aUwcdiHaoup34OMxhK/y3F0GDyfhvGaC+7Cu/PEfbszMz8D9D3XRdMKDwl4f4j1yW5j0906Edrth05Um9x/wI5Pxw7qRL7Ht+XcBlvH4stzJhoJBQgghpJ5tTgQiHmS+H4XvohfHPw0Bp+eQ+tnGQiDNPhdmTllhzEmInvEiutuDqdtBuLb1cCiYl5C8cRmXb/KFGczcSCLzWnlkcbY6MPmDo1z1m4vAfSYC3rKyGeMBJ2zafDclbwdQGLZgUFsuvE4j9uMonKej5XXq3w7L0UmEbisDQq6yJGIXCrCai2vMdtGLOCJnRmH/Ka2lsFXeaYHjYgixZVhlugMJIYQQQpaogORZCyznysGL7ZfnmD5ar8d1URqTJj8Mt6fhaNK+svAkAt/P/fBesLXR1lBC6J8fIHZU/9lqmm9fCtlvTFoaC8HO9cHy1wwWfrCubinusxD2fxiDS2L5oPVYRyEO74b9yP6aRbhUwpnERJ8F2dgCLh/ga5xD7EwA2c/8cP1jaVtAJYOEEEIIWaJ+mE8H4d+jLTLRz5yY+LNZpaYJ7nuhiqrRaoXZCYycB9xtBYJcDrk72mxRPoM0S3N+VC55K3mVR1abXTWvc+og5XpP+MDlIkRT7VZnXxfXWID1vBsbzo9gYnZplccUDBJCCCFk6TaaMXYloLvPcRK+f08i+UZbrKN/YKBxqdyzEOyH5jH2H0e5Wr4lAcKwNqspPIgjCBuG6o0AvmUABm121WwWWNhXSXoQQ1oQsX2blqBj2KxfYyMc/xnD/FEXIi+0pEWgYJAQQggh3bHLg3BE135w1gfbojo9SAh9dRyFcTdEpQNFu4wYGjYh+qLcsC7zZ5it1yD6cxLKo7PkMZ8FbLtZupayarYNwborCqm0yjmk78eBAwNYeKhrIJifR5YFtZbqoHajCPfpHDwXYrrt6wwFg4QQQgjpGuMRPyaPlqs3cxedcN1o1Z2kysMogr+ZYN3duExQ+m0Cx/95HN6TdljE/dj/zxFMzgKmQ25Yf08hozwrB+kpILzNobDZWB4vspBC4o4bzuH2yxwX7U0G8WuTbF23w8AH2dZK8HK3jrPlPthvGGD70oqZB+oag4V8UpLlY66ADVvL+VhIJxA74YRYbFeoY9xtheFKENPPtIROKQPMEEIIIWTVJcb1Y/Y1n/TjH/acv+/KHkG3voJDDkvaY21IXTKx17nlmXktocKCnDgvysKeMfnuX3z5uRw+xD/HJU8ry7I897NVdkfrvljx/KpL9t9v/PhymI+6lLwojVE5n5D9eyCLl1Jsi+bkqYPu0vrXei5PHfPLiUarnJ2WHfy9f3muJXSGSgYJIYSQKvVvnbb0qRXz1/OYn29v8nykvaiJeuvQ7rQkG0X4b/nL7QdzETiPTCL9VltuKo/sU94r2YBNde7ol7/the1MP7xXfBA3q2kLvF3iYREWbXnw2DRcr7yY+KO2glq65UNkix9jH7e+XWAhn0e+namNevCBnWalbWAmp3UAGRjE4KAVtmFeVT0IV8SF7JmJOm0s+bBFERjOj8HcaJUFA7azf9FH0uLGIdSCQkIIIYSQLlqQU+fNWumgIDsi7ZZaNbk7ykJC9u+CLJyYkUuFZPMzspt9hvXq4krFGiuuR+upVNrXjFZ6h1N31bvTpAOyqN+OJWH5wt/7cJitdeeoZJAQQgjpFW/qlDo1mAptlbKtpiwyGbWtoHB0Ev4j7bfP62/Qq6Nwfxq+h4D9oFhq/5e/F0WQD8Oyu9v9ggU4fpV5oVnLabp4R5pmtNI7PJR4q0BELqXgOFnejtVEwSAhhBDSI5Lfb8KmTe1Nk39qL+pJBaS/c8J5PQfs8SPa4fAwxkEeXM1joarOU+kZzAI/04datPgmicB4CNglwrLEgZeXH9uuQ+zfHX4HGB9mzD44u3inmgU2CabBck/uDlAwSAghhPQI87f1S57qTWO6AZ57TWF2Eu4zSTZnxdT1MZg7Gh4GGNzjYkFNGlL1PY77eelfHOlMHoVcHBOfOxF6yJIG+zH34yTiS7mt3rIzQFDGDZyA85YFvqNdHNbmhaT0nq47sHYbKBgkhBBCSPe8iMB1yIckr2aNXIarzsDJrfTvs8O7K47Yg8ob8ZrY+7p2CAietGL0pxysF6bY+wvKfYgNh92lDiW9qR+bNgmA4MDUuAuDHQbIzeQfJRAVxmDdu7jwku5NTAghhJAukRD59AM4bwLm8QTi35oXXfqVvz2KwSsmJGKuDqqYexnLm8+OY+7oNPzD3WwpmGN5bsLM4bTuPsadoZJBQgghpA35O5PwnZvE5NnjGBGPY/IP/f0eCsj8EcHkZ/th+XBoyfeKXZsKSJ5zKoEgbyc4+XWbgWAhh/S9TM3dMwYOBhA1h+C93uGA1T2lgPT1SYTY9sXPHUdo6xi8XQ0EWYh5w4PQzihCiwwEOSoZJIQQQjr1LISRD2NwvpyGY4uWxsKZ2JebMHLLg7tPAx3eRm3tU0ryPgkiJzgQTobhqHOnjLoeTmLokhGxX2x1Oj/kET/rRmy3H4GDa7F8MIkJgwW+nADr+SjC35i72ntYuu3FxDMnAl+blvS+FAwSQgghHeNVcwaEhp/j7r+0IKUQh3fDfkweDiP7q+7+vOvBiwicZiciLOhx/zeDywfbDU0KiJ8xwvn/xZD9xqSl1co/k9C/zdi9DhcrqZBHvtCPgYFur30e0jPAuG3p4SVVExNCCCEdE2DcCcTTuurNJ2nE2T/rsHl9BYJvkpg4wgNB3k4wikDbgSCLk2Yn4fsuB/uO5qV+A2s1EOT6B5YhEOQGuhIIchQMEkIIIW3IP4shdHYUxz93YvRcFKm/WOLrPIqtA6UHMaRhhjEfgnOnAX19H8C+ptu7taOA5Pce+GbZ7MHLCJ4YbO8Wbi/SiP54HKKZ9zo2wfh+d4IasjgUDBJCCCFNsYDnu/0Y3BtE/hM/pn4OI/BRHKM/ag8rckje4eWCvBTLheCDBKYOS4h+5kWkeqy8VVB4HEfonBP7xe2w/yQh/yQCr/UD9BmciPL1e53EpGM7DCyAnehgMGvphgu2s3w8Qeb2KIb+r/4A2TWTcQj2r0IsEOQsGGy3fSFZFhQMEkIIIU3kbrKA58wc7FfD8HyklmD1b9JufbbTqFYJF+aQ4r1oD4/CdciIgX4jRg7ZWEIUqczq9yzu3yFC3FpA/J4BloE4/FdZCLbPyDYugvjtEI5/FcfgsMhCWgnxdJulmc9CGHVE2GuWaNiEQSoYXFUUDBJCCCENJRH6igU8u7xw6drC5f/KKv/du7Q7PjxMgt8ozXZILI2Jt/CGtyYUYfg/dXl15ZFJRtn/OQRu5OEcd8CkbU7waga2H8YgbuHt2gSYt7Vxj1/eTvDoccS0xSXZZUS37ypMOkPBICGEENLIsznEcyxE+lREua9rAan7QfbfBdGsRlTp5DRysMK6u9h1RKs23iNC7Il75maQvsX/D8F71g3TxhzS93m1tgme8z5YN7NtmOXh7AiGdraxvhvNGEvWv01ex9MFce12DnlHUDBICCGENJLPYY79s2zVlV29iiJ4kYVR4y4liOJ3lkj9lgaGRQwVxxx8GMblmwIcXzlg6oVI52EC0yyoNZ3ywLWLrVBhDonrLP2wF+4DPKCVMHefPeGAGaaevqUbWQ4UDBJCCCGN7DDDJbCY8M2CuvxWQuSMB4l9fgSLd9jIZ5C+wwKtvRYM8gRehXrCC3wTRvBIbwyUnMskkIYIp8OiDk6sVWu7jljVau1XScTYNojDQ1Rluw5RMEgIIYQ00i/CezMA4WcvvBd9GHV4kdgdRvr3MZiLdxjZOATbD24YYgH4zo7CbgsBp+cQOy929W4Ti5dH6n4UEEwwbVOLKaVHcaVa27xTXcN8OoEoBmHemkXox2RpuJxlk0sidHL/Ohh6Z22gO5AQQggh7zTtlmgHpzF/1cYCVPXuKc58AKn/epRq7Nyt4zDZ4rBcmELwaxHCe9pL21D4zQvj50DoaQDWdm7Bl89BKqQQMowg88tzTB/tjdLT9YyCQUIIIYQsQQH5PDq8ywYLUPssSFEw2BOompgQQgghi5J/EUfkzCjsP6W1FLIWUckgIYQQQhanEId3w35kf80ifDiL4D+94KMZ1mdF4HePNkQPlQz2EgoGCSGEELI4DycxZIrB/fQuXNu0tLZQMNhLqJqYEEIIIYsiPYghLYjY3lEgSHoNBYOEEEIIWQTtLiYHBrDwkN+hOI3gP/djf8Npkj2D9CKqJiaEEELIIqQx+eEQgh8GEI54oN2Zrw0F5B+G4DKNIvPNDOJnrBDaGZKGLBsKBgkhhBBC1jGqJiaEEEIIWccoGCSEEEIIWccoGCSEEEIIWccoGCSEEEIIWccoGCSEEEIIWccoGCSEEEIIWccoGCSEEEIIWccoGCSEEEIIWccoGCSEEEIIWccoGCSEEEIIWbeA/x9w1RQvkVqc7wAAAABJRU5ErkJggg==)
"""

def propagate(w, b, X, Y):
    """
    Implement the cost function and its gradient for the propagation explained above

    Arguments:
    w -- weights, a numpy array of size (number of features, 1)
    b -- bias, a scalar
    X -- data of size (number of features, number of examples)
    Y -- true "label" vector (containing 0 if non-heart stroke , 1 if heart stroke) of size (1, number of examples)

    Return:
    cost -- negative log-likelihood cost for logistic regression
    dw -- gradient of the loss with respect to w, thus same shape as w
    db -- gradient of the loss with respect to b, thus same shape as b

    """

    m = X.shape[1]

    A = sigmoid(np.dot(w.T, X) + b)
    cost = np.sum(Y * np.log(A) + (1 - Y) * np.log(1 - A)) * (-1/m)

    dw = np.dot(X, (A - Y).T) / m
    db = np.sum(A - Y) / m

    cost = np.squeeze(np.array(cost))


    grads = {"dw": dw,
             "db": db}

    return grads, cost

"""### Optimize w and b

The goal is to learn  ùë§  and  ùëè  by minimizing the cost function  ùêΩ . For a parameter  ùúÉ , the update rule is  ùúÉ=ùúÉ‚àíùõº ùëëùúÉ , where  ùõº  is the learning rate.
"""

def optimize(w, b, X, Y, num_iterations=100, learning_rate=0.009, print_cost=False):
    """
    This function optimizes w and b by running a gradient descent algorithm

    Arguments:
    w -- weights, a numpy array of size (number of features, 1)
    b -- bias, a scalar
    X -- data of shape (number of features, number of examples)
    Y -- true "label" vector (containing 0 if non-heart stroke , 1 if heart stroke) of size (1, number of examples)
    num_iterations -- number of iterations of the optimization loop
    learning_rate -- learning rate of the gradient descent update rule
    print_cost -- True to print the loss every 100 steps

    Returns:
    params -- dictionary containing the weights w and bias b
    grads -- dictionary containing the gradients of the weights and bias with respect to the cost function
    costs -- list of all the costs computed during the optimization, this will be used to plot the learning curve.

    1) Calculate the cost and the gradient for the current parameters. Use propagate().
    2) Update the parameters using gradient descent rule for w and b.
    """

    w = copy.deepcopy(w)
    b = copy.deepcopy(b)

    costs = []

    for i in range(num_iterations):

        grads, cost = propagate(w,b,X,Y)

        dw = grads["dw"]
        db = grads["db"]

        w = w - dw*learning_rate
        b = b - db*learning_rate

        if i % 100 == 0:
            costs.append(cost)

            if print_cost:
                print ("Cost after iteration %i: %f" %(i, cost))

    params = {"w": w,
              "b": b}

    grads = {"dw": dw,
             "db": db}

    return params, grads, costs

"""### Prediction

![image.png](data:image/png;base64,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)
"""

def predict(w, b, X):
    '''
    Predict whether the label is 0 or 1 using learned logistic regression parameters (w, b)

    Arguments:
    w -- weights, a numpy array of size (number of features, 1)
    b -- bias, a scalar
    X -- data of size (number of features, number of examples)

    Returns:
    Y_prediction -- a numpy array (vector) containing all predictions (0/1) for the examples in X
    '''

    m = X.shape[1]
    Y_prediction = np.zeros((1, m))
    w = w.reshape(X.shape[0], 1)

    A = sigmoid(np.dot(w.T, X) + b)


    for i in range(A.shape[1]):

        if A[0, i] > 0.5:
            Y_prediction[0, i] = 1
        else:
            Y_prediction[0, i] = 0

    return Y_prediction

"""##c. Turn everything into model"""

def model(X_train, Y_train, X_test, Y_test, num_iterations=2000, learning_rate=0.005, print_cost=False):
    """
    Builds the logistic regression model

    Arguments:
    X_train -- training set represented by a numpy array of shape (number of features, m_train)
    Y_train -- training labels represented by a numpy array (vector) of shape (1, m_train)
    X_test -- test set represented by a numpy array of shape (number of features, m_test)
    Y_test -- test labels represented by a numpy array (vector) of shape (1, m_test)
    num_iterations -- hyperparameter representing the number of iterations to optimize the parameters
    learning_rate -- hyperparameter representing the learning rate used in the update rule of optimize()
    print_cost -- Set to True to print the cost every 100 iterations

    Returns:
    d -- dictionary containing information about the model.
    """

    w,b = initialize_with_zeros(X_train.shape[0])

    params, grads, costs = optimize(w,b,X_train,Y_train, num_iterations= num_iterations, learning_rate= learning_rate, print_cost= print_cost)


    w = params["w"]
    b = params["b"]
    Y_prediction_test = predict(w, b, X_test)
    Y_prediction_train = predict(w,b, X_train)

    if print_cost:
        print("train accuracy: {} %".format(100 - np.mean(np.abs(Y_prediction_train - Y_train)) * 100))
        print("test accuracy: {} %".format(100 - np.mean(np.abs(Y_prediction_test - Y_test)) * 100))


    d = {"costs": costs,
         "Y_prediction_test": Y_prediction_test,
         "Y_prediction_train" : Y_prediction_train,
         "w" : w,
         "b" : b,
         "learning_rate" : learning_rate,
         "num_iterations": num_iterations}

    return d

"""### Make predict and optimize hyperparameter

#### Make prediction
"""

Logistic_model = model(X_train, y_train, X_test, y_test, print_cost= True, num_iterations= 2000, learning_rate=0.001)

"""#### Optimize learning rate"""

learning_rates = [0.1, 0.01, 0.001, 0.0001]
models = {}

for lr in learning_rates:
    print ("Training a model with learning rate: " + str(lr))
    models[str(lr)] = model(X_train, y_train, X_test, y_test, num_iterations=2000, learning_rate=lr, print_cost=False)
    print ('\n' + "-------------------------------------------------------" + '\n')

for lr in learning_rates:
    plt.plot(np.squeeze(models[str(lr)]["costs"]), label=str(models[str(lr)]["learning_rate"]))

plt.ylabel('cost')
plt.xlabel('iterations (hundreds)')

legend = plt.legend(loc='upper center', shadow=True)
frame = legend.get_frame()
frame.set_facecolor('0.90')
plt.show()

learning_rates = [0.01, 0.001, 0.0001]
models = {}

for lr in learning_rates:
    print ("Training a model with learning rate: " + str(lr))
    models[str(lr)] = model(X_train, y_train, X_test, y_test, num_iterations=2000, learning_rate=lr, print_cost=False)
    print ('\n' + "-------------------------------------------------------" + '\n')

for lr in learning_rates:
    plt.plot(np.squeeze(models[str(lr)]["costs"]), label=str(models[str(lr)]["learning_rate"]))

plt.ylabel('cost')
plt.xlabel('iterations (hundreds)')

legend = plt.legend(loc='upper center', shadow=True)
frame = legend.get_frame()
frame.set_facecolor('0.90')
plt.show()

"""### Prediction using tuned learning rate"""

Logistic_model = model(X_train, y_train, X_test, y_test, print_cost= True, num_iterations= 500, learning_rate=0.01)

"""#5. Using LogisticRegression from sklearn library"""

from sklearn.linear_model import LogisticRegression
# Default rigde regularization
model = LogisticRegression(max_iter= 2000)
model.fit(X_train.T, y_train.reshape(4088,))
predicted_test = model.predict(X_test.T)
predicted_train = model.predict(X_train.T)
print("train accuracy: {} %".format(100 - np.mean(np.abs(predicted_train - y_train)) * 100))
print("test accuracy: {} %".format(100 - np.mean(np.abs(predicted_test - y_test)) * 100))